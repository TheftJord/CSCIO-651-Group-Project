import java.util.*;

class BPlusTree {
    private static final int MIN_KEYS = 2;
    private static final int MAX_KEYS = 4;
    private static final int LEAF_CAPACITY = 16;

    private class Node {
        boolean isLeaf;
        List<Integer> keys = new ArrayList<>();
        Node parent;

        // For index nodes
        List<Node> children = new ArrayList<>();

        // For leaf nodes
        List<String> values = new ArrayList<>();
        Node next; // Pointer to the next leaf node

        Node(boolean isLeaf) {
            this.isLeaf = isLeaf;
        }
    }

    private Node root;
    private int totalSplits = 0;
    private int parentSplits = 0;
    private int totalFusions = 0;
    private int parentFusions = 0;

    public BPlusTree() {
        root = new Node(true);
    }

    // Add a new part
    public void insert(int key, String value) {
        Node leaf = findLeafNode(root, key);
        int pos = Collections.binarySearch(leaf.keys, key);

        if (pos >= 0) {
            // Key exists, update value
            leaf.values.set(pos, value);
        } else {
            pos = -pos - 1;
            leaf.keys.add(pos, key);
            leaf.values.add(pos, value);

            if (leaf.keys.size() > LEAF_CAPACITY) {
                splitLeafNode(leaf);
            }
        }
    }

    // Query for a specific part number
    public String query(int key) {
        Node leaf = findLeafNode(root, key);
        int pos = Collections.binarySearch(leaf.keys, key);
        return pos >= 0 ? leaf.values.get(pos) : null;
    }

    // Display the next 10 parts
    public void displayNextParts(int key) {
        Node leaf = findLeafNode(root, key);
        int pos = Collections.binarySearch(leaf.keys, key);
        pos = pos >= 0 ? pos : -pos - 1;

        int count = 0;
        while (leaf != null && count < 10) {
            for (int i = pos; i < leaf.keys.size() && count < 10; i++) {
                System.out.println("Part ID: " + leaf.keys.get(i) + ", Description: " + leaf.values.get(i));
                count++;
            }
            leaf = leaf.next;
            pos = 0;
        }
    }

    // Modify description of a part
    public boolean modify(int key, String newValue) {
        Node leaf = findLeafNode(root, key);
        int pos = Collections.binarySearch(leaf.keys, key);
        if (pos >= 0) {
            leaf.values.set(pos, newValue);
            return true;
        }
        return false;
    }

    // Delete a part
    /* public boolean delete(int key) {
        // ???

    } */

    // Display tree statistics
    public void displayStatistics() {
        System.out.println("Total Splits: " + totalSplits);
        System.out.println("Parent Splits: " + parentSplits);
        System.out.println("Total Fusions: " + totalFusions);
        System.out.println("Parent Fusions: " + parentFusions);
        System.out.println("Tree Depth: " + getTreeDepth(root));
    }

    // Other methods
    private Node findLeafNode(Node node, int key) {
        if (node.isLeaf) return node;

        for (int i = 0; i < node.keys.size(); i++) {
            if (key < node.keys.get(i)) return node.children.get(i);
        }
        return node.children.get(node.children.size() - 1);
    }

    private void splitLeafNode(Node leaf) {
        totalSplits++;
        Node newLeaf = new Node(true);
        int mid = (leaf.keys.size() + 1) / 2;

        newLeaf.keys.addAll(leaf.keys.subList(mid, leaf.keys.size()));
        newLeaf.values.addAll(leaf.values.subList(mid, leaf.values.size()));
        leaf.keys.subList(mid, leaf.keys.size()).clear();
        leaf.values.subList(mid, leaf.values.size()).clear();

        newLeaf.next = leaf.next;
        leaf.next = newLeaf;

        if (leaf.parent == null) {
            Node newRoot = new Node(false);
            newRoot.keys.add(newLeaf.keys.get(0));
            newRoot.children.add(leaf);
            newRoot.children.add(newLeaf);
            root = newRoot;
            leaf.parent = newRoot;
            newLeaf.parent = newRoot;
            parentSplits++;
        } else {
            insertIntoParent(leaf, newLeaf.keys.get(0), newLeaf);
        }
    }

    private void insertIntoParent(Node oldNode, int key, Node newNode) {
        Node parent = oldNode.parent;
        int pos = Collections.binarySearch(parent.keys, key);

        pos = -pos - 1;
        parent.keys.add(pos, key);
        parent.children.add(pos + 1, newNode);
        newNode.parent = parent;

        if (parent.keys.size() > MAX_KEYS) {
            splitIndexNode(parent);
        }
    }

    private void splitIndexNode(Node indexNode) {
        parentSplits++;
        totalSplits++;

        Node newNode = new Node(false);
        int mid = (indexNode.keys.size() + 1) / 2;

        newNode.keys.addAll(indexNode.keys.subList(mid + 1, indexNode.keys.size()));
        newNode.children.addAll(indexNode.children.subList(mid + 1, indexNode.children.size()));

        for (Node child : newNode.children) {
            child.parent = newNode;
        }

        int midKey = indexNode.keys.get(mid);

        indexNode.keys.subList(mid, indexNode.keys.size()).clear();
        indexNode.children.subList(mid + 1, indexNode.children.size()).clear();

        if (indexNode.parent == null) {
            Node newRoot = new Node(false);
            newRoot.keys.add(midKey);
            newRoot.children.add(indexNode);
            newRoot.children.add(newNode);
            root = newRoot;
            indexNode.parent = newRoot;
            newNode.parent = newRoot;
        } else {
            insertIntoParent(indexNode, midKey, newNode);
        }
    }

    private int getTreeDepth(Node node) {
        int depth = 0;
        while (!node.isLeaf) {
            node = node.children.get(0);
            depth++;
        }
        return depth;
    }
}
